# –§–∞–∑–∞ 1: –ú–æ–¥–µ–ª—å –¥–∞–Ω–Ω—ã—Ö —Ñ–∏–ª—å—Ç—Ä–∞

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** P0 (–∫—Ä–∏—Ç–∏—á–Ω–æ)
**–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:** –ù–µ—Ç
**–°—Ç–∞—Ç—É—Å:** `[x]` –ó–∞–≤–µ—Ä—à–µ–Ω–æ (2026-02-02)

> **‚ö†Ô∏è –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ –¥–ª—è –∞–≥–µ–Ω—Ç–∞:** –í–µ—Å—å –∫–æ–¥ –≤ —ç—Ç–æ–π —Ñ–∞–∑–µ - **–ü–°–ï–í–î–û–ö–û–î –≤ —Å—Ç–∏–ª–µ JavaScript** –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã. –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ç–≤–æ—Ä—á–µ—Å–∫–∏, –∞–¥–∞–ø—Ç–∏—Ä—É—è –ø–æ–¥ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∫–æ–¥–æ–≤—É—é –±–∞–∑—É. –ù–ï —Å–æ–∑–¥–∞–≤–∞–π—Ç–µ markdown —Ñ–∞–π–ª—ã —Å —Ä–µ–∑—é–º–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π.
>
> üí° **–í—Å–µ –ø—Ä–∏–º–µ—Ä—ã ‚Äî –ü–°–ï–í–î–û–ö–û–î!** –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã, –º–µ—Ç–æ–¥—ã –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø–æ–∫–∞–∑–∞–Ω—ã –¥–ª—è –∏–ª–ª—é—Å—Ç—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏–π, –∞ –Ω–µ –¥–ª—è –±—É–∫–≤–∞–ª—å–Ω–æ–≥–æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è.

> **üîê –ö–†–ò–¢–ò–ß–ù–û: DataAccessor Integration**
> 
> –ú–æ–¥–µ–ª—å `FilterAP` **–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û** –¥–æ–ª–∂–Ω–∞ –≤–∫–ª—é—á–∞—Ç—å `userAccessRelation: 'owner'` –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.
> –≠—Ç–æ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é –∑–∞–ø–∏—Å–µ–π –ø–æ –≤–ª–∞–¥–µ–ª—å—Ü—É —á–µ—Ä–µ–∑ `DataAccessor`.
> 
> **–ë–ï–ó –≠–¢–û–ì–û** —Å–∏—Å—Ç–µ–º–∞ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –±—É–¥–µ—Ç —É—è–∑–≤–∏–º–∞ - –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å–º–æ–≥—É—Ç –≤–∏–¥–µ—Ç—å —á—É–∂–∏–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã!
> 
> –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —Ñ–∏–ª—å—Ç—Ä–∞–º–∏ –¥–æ–ª–∂–Ω—ã –∏–¥—Ç–∏ —á–µ—Ä–µ–∑ `DataAccessor`, –∞ –ù–ï —á–µ—Ä–µ–∑ –ø—Ä—è–º—ã–µ –≤—ã–∑–æ–≤—ã ORM.
> –°–º. –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é: `docs/AccessRights/user-owned-records.md`

---

## –¶–µ–ª—å

–°–æ–∑–¥–∞—Ç—å –±–∞–∑–æ–≤—ã–µ –º–æ–¥–µ–ª–∏ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∏ –∏—Ö –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∫–æ–ª–æ–Ω–æ–∫.

---

## –ó–∞–¥–∞—á–∏

- [x] 1.1 –°–æ–∑–¥–∞—Ç—å –º–æ–¥–µ–ª—å `FilterAP`
  - [x] 1.1.1 –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å FilterAPAttributes
  - [x] 1.1.2 –°–æ–∑–¥–∞—Ç—å —Å—Ö–µ–º—É FilterAPSchema
  - [x] 1.1.3 **–ö–†–ò–¢–ò–ß–ù–û:** –î–æ–±–∞–≤–∏—Ç—å `userAccessRelation: 'owner'`
  - [x] 1.1.4 –ù–∞—Å—Ç—Ä–æ–∏—Ç—å associations (owner: BelongsTo UserAP)
- [x] 1.2 –°–æ–∑–¥–∞—Ç—å –º–æ–¥–µ–ª—å `FilterColumnAP`
- [x] 1.3 –î–æ–±–∞–≤–∏—Ç—å Sequelize –∞–¥–∞–ø—Ç–µ—Ä (umzug –º–∏–≥—Ä–∞—Ü–∏—è)
- [x] 1.4 –î–æ–±–∞–≤–∏—Ç—å Waterline –∞–¥–∞–ø—Ç–µ—Ä (knex –º–∏–≥—Ä–∞—Ü–∏—è)
- [x] 1.5 –°–æ–∑–¥–∞—Ç—å –º–∏–≥—Ä–∞—Ü–∏–∏
- [x] 1.6 –î–æ–±–∞–≤–∏—Ç—å —Å–≤—è–∑–∏ —Å UserAP –∏ GroupAP
- [x] 1.7 –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –º–æ–¥–µ–ª–µ–π (—á–µ—Ä–µ–∑ fixture/adminizerConfig.ts)
- [ ] 1.8 Unit —Ç–µ—Å—Ç—ã (85%+ coverage)
  - [ ] 1.8.1 FilterAP CRUD –æ–ø–µ—Ä–∞—Ü–∏–∏
  - [ ] 1.8.2 FilterAP –≤–∞–ª–∏–¥–∞—Ü–∏—è –ø–æ–ª–µ–π
  - [ ] 1.8.3 FilterAP unique constraints
  - [ ] 1.8.4 FilterAP JSON —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è
  - [ ] 1.8.5 FilterAP associations
  - [ ] 1.8.6 FilterColumnAP CRUD –æ–ø–µ—Ä–∞—Ü–∏–∏
  - [ ] 1.8.7 FilterColumnAP associations
  - [ ] 1.8.8 CustomFieldHandler —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
  - [ ] 1.8.9 CustomFieldHandler buildCondition –¥–ª—è –≤—Å–µ—Ö –¥–∏–∞–ª–µ–∫—Ç–æ–≤
  - [ ] 1.8.10 CustomFieldHandler –≤–∞–ª–∏–¥–∞—Ü–∏—è
- [ ] 1.9 Integration —Ç–µ—Å—Ç—ã
  - [ ] 1.9.1 –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
  - [ ] 1.9.2 Cascade delete
  - [ ] 1.9.3 –ú–∏–≥—Ä–∞—Ü–∏–∏ (up/down)
  - [ ] 1.9.4 **–°–≤—è–∑–∏ —á–µ—Ä–µ–∑ DataAccessor (userAccessRelation)**
  - [ ] 1.9.5 –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –ø–æ –≤–ª–∞–¥–µ–ª—å—Ü—É

---

## 1.1 –ú–æ–¥–µ–ª—å FilterAP

**–§–∞–π–ª:** `src/models/FilterAP.ts`

```typescript
import { AbstractModel } from '../lib/model/AbstractModel';

export interface FilterAPAttributes {
  id: string;                      // UUID (–Ω–µ auto-increment!)

  // –û—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
  name: string;                    // –ù–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–∞
  description?: string;            // –û–ø–∏—Å–∞–Ω–∏–µ
  modelName: string;               // –ö –∫–∞–∫–æ–π –º–æ–¥–µ–ª–∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è
  slug: string;                    // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π slug –¥–ª—è URL/API

  // –£—Å–ª–æ–≤–∏—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ (JSON)
  conditions: FilterCondition[];

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
  sortField?: string;
  sortDirection?: 'ASC' | 'DESC';

  // –ü—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
  visibility: 'private' | 'public' | 'groups' | 'system';
  owner: number;                   // BelongsTo UserAP (–¥–ª—è DataAccessor)
  groupIds?: number[];
  isSystemFilter?: boolean;        // –°–∏—Å—Ç–µ–º–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä (—Å–∫—Ä—ã—Ç –æ—Ç UI —Å–ø–∏—Å–∫–∞)

  // API –¥–æ—Å—Ç—É–ø
  apiEnabled: boolean;
  apiKey?: string;

  // UI –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
  icon?: string;
  color?: string;
  isPinned?: boolean;

  // –í–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
  version: number;              // –í–µ—Ä—Å–∏—è —Ñ–æ—Ä–º–∞—Ç–∞ —Ñ–∏–ª—å—Ç—Ä–∞ (–Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 1)
  schemaVersion?: string;       // –í–µ—Ä—Å–∏—è —Å—Ö–µ–º—ã –º–æ–¥–µ–ª–∏ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏

  createdAt: Date;
  updatedAt: Date;
}

export interface FilterCondition {
  id: string;                      // UUID
  field: string;
  operator: FilterOperator;
  value: any;

  // –í–ª–æ–∂–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è
  logic?: 'AND' | 'OR' | 'NOT';
  children?: FilterCondition[];

  // –î–ª—è —Å–≤—è–∑–µ–π
  relation?: string;
  relationField?: string;
  
  // –ö–∞—Å—Ç–æ–º–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ (–¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –ø–æ–ª–µ–π)
  customHandler?: string;          // ID –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞
  customHandlerParams?: any;       // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞
  
  // Raw SQL (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –≥–∏–±–∫–æ—Å—Ç–∏)
  rawSQL?: string;                 // Raw SQL —É—Å–ª–æ–≤–∏–µ
  rawSQLParams?: any[];            // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è SQL
}

export type FilterOperator =
  | 'eq'           // =
  | 'neq'          // !=
  | 'gt'           // >
  | 'gte'          // >=
  | 'lt'           // <
  | 'lte'          // <=
  | 'like'         // LIKE %value%
  | 'ilike'        // ILIKE %value% (case-insensitive)
  | 'startsWith'   // LIKE value%
  | 'endsWith'     // LIKE %value
  | 'in'           // IN (array)
  | 'notIn'        // NOT IN
  | 'between'      // BETWEEN
  | 'isNull'       // IS NULL
  | 'isNotNull'    // IS NOT NULL
  | 'regex'        // –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
  | 'custom';      // –ö–∞—Å—Ç–æ–º–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫

export const FilterAPSchema = {
  attributes: {
    id: {
      type: 'string',
      primaryKey: true,
      defaultsTo: () => crypto.randomUUID()  // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º UUID
    },
    name: {
      type: 'string',
      required: true,
      maxLength: 255
    },
    description: {
      type: 'text'
    },
    modelName: {
      type: 'string',
      required: true,
      maxLength: 100
    },
    slug: {
      type: 'string',
      required: true,
      unique: true,
      maxLength: 100
    },
    conditions: {
      type: 'json',
      defaultsTo: []
    },
    sortField: {
      type: 'string',
      maxLength: 100
    },
    sortDirection: {
      type: 'string',
      isIn: ['ASC', 'DESC'],
      defaultsTo: 'ASC'
    },
    visibility: {
      type: 'string',
      isIn: ['private', 'public', 'groups'],
      defaultsTo: 'private'
    },
    owner: {
      type: 'number',
      required: true
    },
    groupIds: {
      type: 'json',
      defaultsTo: []
    },
    apiEnabled: {
      type: 'boolean',
      defaultsTo: false
    },
    apiKey: {
      type: 'string',
      unique: true,
      maxLength: 64
    },
    icon: {
      type: 'string',
      maxLength: 50
    },
    color: {
      type: 'string',
      maxLength: 50
    },
    isPinned: {
      type: 'boolean',
      defaultsTo: false
    },
    isSystemFilter: {
      type: 'boolean',
      defaultsTo: false,
      description: '–°–∏—Å—Ç–µ–º–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä - –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –≤ —Å–ø–∏—Å–∫–µ UI'
    },
    createdAt: {
      type: 'datetime',
      autoCreatedAt: true
    },
    updatedAt: {
      type: 'datetime',
      autoUpdatedAt: true
    }
  },

  // –ü—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ DataAccessor
  userAccessRelation: 'owner',

  // –°–≤—è–∑–∏
  associations: {
    owner: {
      model: 'UserAP',
      type: 'belongsTo',
      foreignKey: 'owner'
    },
    columns: {
      model: 'FilterColumnAP',
      type: 'hasMany',
      foreignKey: 'filterId'
    }
  }
};
```

---

## 1.2 –ú–æ–¥–µ–ª—å FilterColumnAP

**–§–∞–π–ª:** `src/models/FilterColumnAP.ts`

```typescript
export interface FilterColumnAPAttributes {
  id: number;
  filterId: number;
  fieldName: string;
  order: number;
  width?: number;
  isVisible: boolean;
  isEditable: boolean;
}

export const FilterColumnAPSchema = {
  attributes: {
    id: {
      type: 'number',
      autoIncrement: true,
      primaryKey: true
    },
    filterId: {
      type: 'number',
      required: true
    },
    fieldName: {
      type: 'string',
      required: true,
      maxLength: 100
    },
    order: {
      type: 'number',
      defaultsTo: 0
    },
    width: {
      type: 'number'
    },
    isVisible: {
      type: 'boolean',
      defaultsTo: true
    },
    isEditable: {
      type: 'boolean',
      defaultsTo: false
    }
  },

  associations: {
    filter: {
      model: 'FilterAP',
      type: 'belongsTo',
      foreignKey: 'filterId'
    }
  }
};
```

---

## 1.3 Sequelize –∞–¥–∞–ø—Ç–µ—Ä

**–§–∞–π–ª:** `src/lib/model/adapter/sequelize.ts` (–¥–æ–ø–æ–ª–Ω–∏—Ç—å)

–î–æ–±–∞–≤–∏—Ç—å –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∞–¥–∞–ø—Ç–µ—Ä –ø–æ–¥–¥–µ—Ä–∂–∫—É –º–æ–¥–µ–ª–µ–π FilterAP –∏ FilterColumnAP.

```typescript
// –í –º–µ—Ç–æ–¥–µ buildSequelizeModel –¥–æ–±–∞–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É JSON –ø–æ–ª–µ–π:
if (attr.type === 'json') {
  sequelizeAttr.type = DataTypes.JSON;
  if (attr.defaultsTo !== undefined) {
    sequelizeAttr.defaultValue = attr.defaultsTo;
  }
}
```

---

## 1.4 –ú–∏–≥—Ä–∞—Ü–∏—è Sequelize

**–§–∞–π–ª:** `src/migrations/YYYYMMDDHHMMSS-create-filter-ap.ts`

```typescript
import { QueryInterface, DataTypes } from 'sequelize';

export async function up(queryInterface: QueryInterface): Promise<void> {
  // FilterAP
  await queryInterface.createTable('FilterAP', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    name: {
      type: DataTypes.STRING(255),
      allowNull: false
    },
    description: {
      type: DataTypes.TEXT,
      allowNull: true
    },
    modelName: {
      type: DataTypes.STRING(100),
      allowNull: false
    },
    slug: {
      type: DataTypes.STRING(100),
      allowNull: false,
      unique: true
    },
    conditions: {
      type: DataTypes.JSON,
      defaultValue: []
    },
    sortField: {
      type: DataTypes.STRING(100),
      allowNull: true
    },
    sortDirection: {
      type: DataTypes.ENUM('ASC', 'DESC'),
      defaultValue: 'ASC'
    },
    visibility: {
      type: DataTypes.ENUM('private', 'public', 'groups'),
      defaultValue: 'private'
    },
    owner: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'UserAP',
        key: 'id'
      },
      onDelete: 'CASCADE'
    },
    groupIds: {
      type: DataTypes.JSON,
      defaultValue: []
    },
    apiEnabled: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    apiKey: {
      type: DataTypes.STRING(64),
      unique: true,
      allowNull: true
    },
    icon: {
      type: DataTypes.STRING(50),
      allowNull: true
    },
    color: {
      type: DataTypes.STRING(50),
      allowNull: true
    },
    isPinned: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    isSystemFilter: {
      type: DataTypes.BOOLEAN,
      defaultValue: false,
      comment: '–°–∏—Å—Ç–µ–º–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä - –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –≤ —Å–ø–∏—Å–∫–µ UI'
    },
    createdAt: {
      type: DataTypes.DATE,
      allowNull: false
    },
    updatedAt: {
      type: DataTypes.DATE,
      allowNull: false
    }
  });

  // –ò–Ω–¥–µ–∫—Å—ã
  await queryInterface.addIndex('FilterAP', ['modelName']);
  await queryInterface.addIndex('FilterAP', ['ownerId']);
  await queryInterface.addIndex('FilterAP', ['apiKey']);
  await queryInterface.addIndex('FilterAP', ['slug']);

  // FilterColumnAP
  await queryInterface.createTable('FilterColumnAP', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    filterId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'FilterAP',
        key: 'id'
      },
      onDelete: 'CASCADE'
    },
    fieldName: {
      type: DataTypes.STRING(100),
      allowNull: false
    },
    order: {
      type: DataTypes.INTEGER,
      defaultValue: 0
    },
    width: {
      type: DataTypes.INTEGER,
      allowNull: true
    },
    isVisible: {
      type: DataTypes.BOOLEAN,
      defaultValue: true
    },
    isEditable: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    }
  });

  await queryInterface.addIndex('FilterColumnAP', ['filterId']);
}

export async function down(queryInterface: QueryInterface): Promise<void> {
  await queryInterface.dropTable('FilterColumnAP');
  await queryInterface.dropTable('FilterAP');
}
```

---

## 1.5 –°–≤—è–∑–∏ —Å UserAP –∏ GroupAP

–í `src/models/UserAP.ts` –¥–æ–±–∞–≤–∏—Ç—å:

```typescript
// –í associations:
filters: {
  model: 'FilterAP',
  type: 'hasMany',
  foreignKey: 'ownerId'
}
```

---

## 1.6 –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –º–æ–¥–µ–ª–µ–π

**–§–∞–π–ª:** `src/system/bindFilters.ts`

```typescript
import { FilterAPSchema } from '../models/FilterAP';
import { FilterColumnAPSchema } from '../models/FilterColumnAP';

export async function bindFilterModels(adminizer: Adminizer): Promise<void> {
  // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –º–æ–¥–µ–ª–µ–π
  adminizer.modelHandler.registerModel('FilterAP', FilterAPSchema);
  adminizer.modelHandler.registerModel('FilterColumnAP', FilterColumnAPSchema);

  // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å –ë–î (–µ—Å–ª–∏ auto-sync –≤–∫–ª—é—á–µ–Ω)
  if (adminizer.config.autoSyncModels) {
    await adminizer.modelHandler.syncModel('FilterAP');
    await adminizer.modelHandler.syncModel('FilterColumnAP');
  }
}
```

---

## 1.7 –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤ (–≤–∫–ª—é—á–µ–Ω–∏–µ/–æ—Ç–∫–ª—é—á–µ–Ω–∏–µ)

**–§–∞–π–ª:** `src/interfaces/adminpanelConfig.ts` (—Ä–∞—Å—à–∏—Ä–∏—Ç—å)

```typescript
interface AdminizerConfig {
  // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏

  /**
   * –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –≤–∫–ª—é—á–µ–Ω–∏–µ/–æ—Ç–∫–ª—é—á–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —Ñ–∏–ª—å—Ç—Ä–æ–≤
   * @default true
   */
  filtersEnabled?: boolean;

  /**
   * –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
   */
  modelFilters?: {
    [modelName: string]: {
      /**
       * –í–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã –¥–ª—è —ç—Ç–æ–π –º–æ–¥–µ–ª–∏
       * –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É filtersEnabled
       * @default undefined (–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É)
       */
      enabled?: boolean;

      /**
       * –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç–∞—Ä—ã–π –ø–æ–∏—Å–∫ –≤–º–µ—Å—Ç–æ —Ñ–∏–ª—å—Ç—Ä–æ–≤
       * @default false
       */
      useLegacySearch?: boolean;
    };
  };
}
```

**–ü—Ä–∏–º–µ—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏:**

```typescript
// –í –∫–æ–Ω—Ñ–∏–≥–µ Adminizer
const adminizer = new Adminizer({
  // –ì–ª–æ–±–∞–ª—å–Ω–æ –≤–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã
  filtersEnabled: true,

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
  modelFilters: {
    // –û—Ç–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã –¥–ª—è –º–æ–¥–µ–ª–∏ UserAP
    UserAP: {
      enabled: false,
      useLegacySearch: true  // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç–∞—Ä—ã–π –ø–æ–∏—Å–∫
    },

    // –í–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã –¥–ª—è OrderAP (–ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É)
    OrderAP: {
      enabled: true
    },

    // –î–ª—è CategoryAP –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É
    // (–Ω–µ —É–∫–∞–∑—ã–≤–∞–µ–º)
  },

  // ... –¥—Ä—É–≥–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
});
```

**–¢–∞–∫–∂–µ –º–æ–∂–Ω–æ –æ—Ç–∫–ª—é—á–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω–æ:**

```typescript
const adminizer = new Adminizer({
  // –ì–ª–æ–±–∞–ª—å–Ω–æ –æ—Ç–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã (–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç–∞—Ä—ã–π –ø–æ–∏—Å–∫ –≤–µ–∑–¥–µ)
  filtersEnabled: false,

  // –ù–æ –≤–∫–ª—é—á–∏—Ç—å –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
  modelFilters: {
    OrderAP: {
      enabled: true  // –¢–æ–ª—å–∫–æ –¥–ª—è OrderAP –±—É–¥—É—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã
    }
  }
});
```

---

## 1.8 –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –º–æ–¥–µ–ª–µ–π

**–§–∞–π–ª:** `src/system/bindModels.ts` (–¥–æ–ø–æ–ª–Ω–∏—Ç—å)

```typescript
export async function registerFilterModels(adminizer: Adminizer) {
  // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –º–æ–¥–µ–ª–µ–π
  adminizer.modelHandler.registerModel('FilterAP', FilterAPSchema);
  adminizer.modelHandler.registerModel('FilterColumnAP', FilterColumnAPSchema);

  // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å –ë–î (–µ—Å–ª–∏ auto-sync –≤–∫–ª—é—á–µ–Ω)
  if (adminizer.config.autoSyncModels) {
    await adminizer.modelHandler.syncModel('FilterAP');
    await adminizer.modelHandler.syncModel('FilterColumnAP');
  }
}
```

---

## 1.9 Unit —Ç–µ—Å—Ç—ã

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** P0 (–∫—Ä–∏—Ç–∏—á–Ω–æ)
**–¶–µ–ª—å coverage:** 85%+
**–í—Ä–µ–º—è:** 1 –¥–µ–Ω—å

### 1.8.1 FilterAP CRUD —Ç–µ—Å—Ç—ã

**–§–∞–π–ª:** `tests/models/FilterAP.test.ts`

```typescript
import { FilterAP, FilterColumnAP, UserAP } from '../../src/models';
import { setupTestDatabase, teardownTestDatabase } from '../helpers/database';

describe('FilterAP Model', () => {
  let testUser: UserAP;

  beforeAll(async () => {
    await setupTestDatabase();
    testUser = await UserAP.create({
      login: 'testuser',
      email: 'test@test.com',
      passwordHashed: 'hash'
    });
  });

  afterAll(async () => {
    await FilterAP.destroy({ where: {} });
    await UserAP.destroy({ where: { id: testUser.id } });
    await teardownTestDatabase();
  });

  describe('create', () => {
    it('should create filter with required fields', async () => {
      const filter = await FilterAP.create({
        name: 'Test Filter',
        modelName: 'UserAP',
        slug: 'test-filter',
        conditions: [],
        ownerId: testUser.id
      });

      expect(filter.id).toBeDefined();
      expect(filter.name).toBe('Test Filter');
      expect(filter.visibility).toBe('private'); // default value
      expect(filter.apiEnabled).toBe(false); // default value
      expect(filter.version).toBe(1); // default version
    });

    it('should throw error when required fields missing', async () => {
      await expect(
        FilterAP.create({
          name: 'Incomplete',
          // missing modelName, slug, ownerId
        } as any)
      ).rejects.toThrow();
    });

    it('should enforce unique slug', async () => {
      await FilterAP.create({
        name: 'Filter 1',
        modelName: 'UserAP',
        slug: 'unique-slug',
        conditions: [],
        ownerId: testUser.id
      });

      await expect(
        FilterAP.create({
          name: 'Filter 2',
          modelName: 'UserAP',
          slug: 'unique-slug', // duplicate!
          conditions: [],
          ownerId: testUser.id
        })
      ).rejects.toThrow(/unique/i);
    });

    it('should enforce unique apiKey', async () => {
      const apiKey = 'test-api-key-12345';
      
      await FilterAP.create({
        name: 'Filter 1',
        modelName: 'UserAP',
        slug: 'filter-1',
        conditions: [],
        ownerId: testUser.id,
        apiEnabled: true,
        apiKey
      });

      await expect(
        FilterAP.create({
          name: 'Filter 2',
          modelName: 'UserAP',
          slug: 'filter-2',
          conditions: [],
          ownerId: testUser.id,
          apiEnabled: true,
          apiKey // duplicate!
        })
      ).rejects.toThrow(/unique/i);
    });

    it('should validate visibility enum', async () => {
      await expect(
        FilterAP.create({
          name: 'Invalid',
          modelName: 'UserAP',
          slug: 'invalid',
          conditions: [],
          ownerId: testUser.id,
          visibility: 'invalid' as any
        })
      ).rejects.toThrow();
    });

    it('should validate sortDirection enum', async () => {
      await expect(
        FilterAP.create({
          name: 'Invalid Sort',
          modelName: 'UserAP',
          slug: 'invalid-sort',
          conditions: [],
          ownerId: testUser.id,
          sortDirection: 'INVALID' as any
        })
      ).rejects.toThrow();
    });
  });

  describe('read', () => {
    let filter: FilterAP;

    beforeEach(async () => {
      filter = await FilterAP.create({
        name: 'Read Test',
        modelName: 'UserAP',
        slug: 'read-test',
        conditions: [
          { id: '1', field: 'status', operator: 'eq', value: 'active' }
        ],
        ownerId: testUser.id
      });
    });

    afterEach(async () => {
      await FilterAP.destroy({ where: { id: filter.id } });
    });

    it('should find filter by id', async () => {
      const found = await FilterAP.findOne({ where: { id: filter.id } });
      expect(found).toBeDefined();
      expect(found!.name).toBe('Read Test');
    });

    it('should find filter by slug', async () => {
      const found = await FilterAP.findOne({ where: { slug: 'read-test' } });
      expect(found).toBeDefined();
      expect(found!.id).toBe(filter.id);
    });

    it('should list filters by modelName', async () => {
      const filters = await FilterAP.findAll({ where: { modelName: 'UserAP' } });
      expect(filters.length).toBeGreaterThan(0);
      expect(filters.some(f => f.id === filter.id)).toBe(true);
    });

    it('should list filters by ownerId', async () => {
      const filters = await FilterAP.findAll({ where: { ownerId: testUser.id } });
      expect(filters.length).toBeGreaterThan(0);
      expect(filters.every(f => f.ownerId === testUser.id)).toBe(true);
    });
  });

  describe('update', () => {
    let filter: FilterAP;

    beforeEach(async () => {
      filter = await FilterAP.create({
        name: 'Update Test',
        modelName: 'UserAP',
        slug: 'update-test',
        conditions: [],
        ownerId: testUser.id
      });
    });

    afterEach(async () => {
      await FilterAP.destroy({ where: { id: filter.id } });
    });

    it('should update name', async () => {
      await filter.update({ name: 'Updated Name' });
      const reloaded = await FilterAP.findOne({ where: { id: filter.id } });
      expect(reloaded!.name).toBe('Updated Name');
    });

    it('should update conditions', async () => {
      const newConditions = [
        { id: '1', field: 'age', operator: 'gt', value: 18 }
      ];
      await filter.update({ conditions: newConditions });
      const reloaded = await FilterAP.findOne({ where: { id: filter.id } });
      expect(reloaded!.conditions).toEqual(newConditions);
    });

    it('should update updatedAt timestamp', async () => {
      const oldTimestamp = filter.updatedAt;
      await new Promise(resolve => setTimeout(resolve, 100)); // wait 100ms
      await filter.update({ name: 'Changed' });
      expect(filter.updatedAt.getTime()).toBeGreaterThan(oldTimestamp.getTime());
    });
  });

  describe('delete', () => {
    it('should delete filter', async () => {
      const filter = await FilterAP.create({
        name: 'Delete Test',
        modelName: 'UserAP',
        slug: 'delete-test',
        conditions: [],
        ownerId: testUser.id
      });

      await filter.destroy();
      
      const found = await FilterAP.findOne({ where: { id: filter.id } });
      expect(found).toBeNull();
    });
  });

  describe('JSON serialization', () => {
    it('should store simple conditions as JSON', async () => {
      const conditions = [
        { id: '1', field: 'status', operator: 'eq', value: 'active' }
      ];

      const filter = await FilterAP.create({
        name: 'JSON Test',
        modelName: 'UserAP',
        slug: 'json-test',
        conditions,
        ownerId: testUser.id
      });

      const loaded = await FilterAP.findOne({ where: { id: filter.id } });
      expect(loaded!.conditions).toEqual(conditions);
    });

    it('should store complex nested conditions as JSON', async () => {
      const conditions = [
        {
          id: 'group1',
          logic: 'AND',
          children: [
            { id: '1', field: 'status', operator: 'eq', value: 'active' },
            {
              id: 'group2',
              logic: 'OR',
              children: [
                { id: '2', field: 'role', operator: 'eq', value: 'admin' },
                { id: '3', field: 'role', operator: 'eq', value: 'moderator' }
              ]
            }
          ]
        }
      ];

      const filter = await FilterAP.create({
        name: 'Complex JSON Test',
        modelName: 'UserAP',
        slug: 'complex-json-test',
        conditions,
        ownerId: testUser.id
      });

      const loaded = await FilterAP.findOne({ where: { id: filter.id } });
      expect(loaded!.conditions).toEqual(conditions);
    });

    it('should store groupIds as JSON array', async () => {
      const groupIds = [1, 2, 3];

      const filter = await FilterAP.create({
        name: 'Groups Test',
        modelName: 'UserAP',
        slug: 'groups-test',
        conditions: [],
        ownerId: testUser.id,
        visibility: 'groups',
        groupIds
      });

      const loaded = await FilterAP.findOne({ where: { id: filter.id } });
      expect(loaded!.groupIds).toEqual(groupIds);
    });
  });

  describe('associations', () => {
    it('should belong to owner (UserAP)', async () => {
      const filter = await FilterAP.create({
        name: 'Owner Test',
        modelName: 'UserAP',
        slug: 'owner-test',
        conditions: [],
        ownerId: testUser.id
      });

      const loaded = await FilterAP.findOne({
        where: { id: filter.id },
        include: ['owner']
      });

      expect(loaded!.owner).toBeDefined();
      expect(loaded!.owner.id).toBe(testUser.id);
      expect(loaded!.owner.login).toBe('testuser');
    });

    it('should have many columns (FilterColumnAP)', async () => {
      const filter = await FilterAP.create({
        name: 'Columns Test',
        modelName: 'UserAP',
        slug: 'columns-test',
        conditions: [],
        ownerId: testUser.id
      });

      await FilterColumnAP.bulkCreate([
        { filterId: filter.id, fieldName: 'id', order: 0 },
        { filterId: filter.id, fieldName: 'name', order: 1 },
        { filterId: filter.id, fieldName: 'email', order: 2 }
      ]);

      const loaded = await FilterAP.findOne({
        where: { id: filter.id },
        include: ['columns']
      });

      expect(loaded!.columns).toBeDefined();
      expect(loaded!.columns.length).toBe(3);
      expect(loaded!.columns[0].fieldName).toBe('id');
    });

    it('should cascade delete columns when filter deleted', async () => {
      const filter = await FilterAP.create({
        name: 'Cascade Test',
        modelName: 'UserAP',
        slug: 'cascade-test',
        conditions: [],
        ownerId: testUser.id
      });

      const column = await FilterColumnAP.create({
        filterId: filter.id,
        fieldName: 'test',
        order: 0
      });

      await filter.destroy();

      const foundColumn = await FilterColumnAP.findOne({ where: { id: column.id } });
      expect(foundColumn).toBeNull();
    });
  });

  describe('default values', () => {
    it('should set default visibility to private', async () => {
      const filter = await FilterAP.create({
        name: 'Default Visibility',
        modelName: 'UserAP',
        slug: 'default-visibility',
        conditions: [],
        ownerId: testUser.id
      });

      expect(filter.visibility).toBe('private');
    });

    it('should set default apiEnabled to false', async () => {
      const filter = await FilterAP.create({
        name: 'Default API',
        modelName: 'UserAP',
        slug: 'default-api',
        conditions: [],
        ownerId: testUser.id
      });

      expect(filter.apiEnabled).toBe(false);
    });

    it('should set default isPinned to false', async () => {
      const filter = await FilterAP.create({
        name: 'Default Pinned',
        modelName: 'UserAP',
        slug: 'default-pinned',
        conditions: [],
        ownerId: testUser.id
      });

      expect(filter.isPinned).toBe(false);
    });

    it('should set default isSystemFilter to false', async () => {
      const filter = await FilterAP.create({
        name: 'Default System',
        modelName: 'UserAP',
        slug: 'default-system',
        conditions: [],
        ownerId: testUser.id
      });

      expect(filter.isSystemFilter).toBe(false);
    });

    it('should allow creating system filter', async () => {
      const filter = await FilterAP.create({
        name: 'Integration Filter',
        modelName: 'UserAP',
        slug: 'integration-filter',
        conditions: [],
        ownerId: testUser.id,
        isSystemFilter: true
      });

      expect(filter.isSystemFilter).toBe(true);
    });

    it('should set default version to 1', async () => {
      const filter = await FilterAP.create({
        name: 'Default Version',
        modelName: 'UserAP',
        slug: 'default-version',
        conditions: [],
        ownerId: testUser.id
      });

      expect(filter.version).toBe(1);
    });

    it('should set default conditions to empty array', async () => {
      const filter = await FilterAP.create({
        name: 'Default Conditions',
        modelName: 'UserAP',
        slug: 'default-conditions',
        ownerId: testUser.id
      });

      expect(filter.conditions).toEqual([]);
    });
  });

  describe('indexes', () => {
    it('should have index on modelName for fast lookups', async () => {
      // –°–æ–∑–¥–∞—Ç—å –º–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–æ–≤
      const filters = Array.from({ length: 100 }, (_, i) => ({
        name: `Filter ${i}`,
        modelName: i % 2 === 0 ? 'UserAP' : 'OrderAP',
        slug: `filter-${i}`,
        conditions: [],
        ownerId: testUser.id
      }));
      
      await FilterAP.bulkCreate(filters);

      const start = Date.now();
      await FilterAP.findAll({ where: { modelName: 'UserAP' } });
      const duration = Date.now() - start;

      // –° –∏–Ω–¥–µ–∫—Å–æ–º –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –±—ã—Å—Ç—Ä–æ
      expect(duration).toBeLessThan(50); // < 50ms
    });
  });
});
```

### 1.8.2 FilterColumnAP CRUD —Ç–µ—Å—Ç—ã

**–§–∞–π–ª:** `tests/models/FilterColumnAP.test.ts`

```typescript
import { FilterAP, FilterColumnAP, UserAP } from '../../src/models';

describe('FilterColumnAP Model', () => {
  let testUser: UserAP;
  let testFilter: FilterAP;

  beforeAll(async () => {
    testUser = await UserAP.create({
      login: 'testuser',
      email: 'test@test.com',
      passwordHashed: 'hash'
    });

    testFilter = await FilterAP.create({
      name: 'Test Filter',
      modelName: 'UserAP',
      slug: 'test-filter',
      conditions: [],
      ownerId: testUser.id
    });
  });

  afterAll(async () => {
    await FilterColumnAP.destroy({ where: {} });
    await FilterAP.destroy({ where: {} });
    await UserAP.destroy({ where: {} });
  });

  describe('create', () => {
    it('should create column with required fields', async () => {
      const column = await FilterColumnAP.create({
        filterId: testFilter.id,
        fieldName: 'name',
        order: 0
      });

      expect(column.id).toBeDefined();
      expect(column.filterId).toBe(testFilter.id);
      expect(column.fieldName).toBe('name');
      expect(column.order).toBe(0);
      expect(column.isVisible).toBe(true); // default
      expect(column.isEditable).toBe(false); // default
    });

    it('should throw error when filterId invalid', async () => {
      await expect(
        FilterColumnAP.create({
          filterId: 999999, // –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
          fieldName: 'name',
          order: 0
        })
      ).rejects.toThrow();
    });
  });

  describe('ordering', () => {
    beforeEach(async () => {
      await FilterColumnAP.destroy({ where: { filterId: testFilter.id } });
    });

    it('should maintain column order', async () => {
      await FilterColumnAP.bulkCreate([
        { filterId: testFilter.id, fieldName: 'id', order: 0 },
        { filterId: testFilter.id, fieldName: 'name', order: 1 },
        { filterId: testFilter.id, fieldName: 'email', order: 2 }
      ]);

      const columns = await FilterColumnAP.findAll({
        where: { filterId: testFilter.id },
        order: [['order', 'ASC']]
      });

      expect(columns.map(c => c.fieldName)).toEqual(['id', 'name', 'email']);
    });

    it('should update column order', async () => {
      const column = await FilterColumnAP.create({
        filterId: testFilter.id,
        fieldName: 'name',
        order: 0
      });

      await column.update({ order: 5 });

      const updated = await FilterColumnAP.findOne({ where: { id: column.id } });
      expect(updated!.order).toBe(5);
    });
  });

  describe('visibility and editability', () => {
    it('should toggle visibility', async () => {
      const column = await FilterColumnAP.create({
        filterId: testFilter.id,
        fieldName: 'name',
        order: 0
      });

      await column.update({ isVisible: false });
      expect(column.isVisible).toBe(false);

      await column.update({ isVisible: true });
      expect(column.isVisible).toBe(true);
    });

    it('should toggle editability', async () => {
      const column = await FilterColumnAP.create({
        filterId: testFilter.id,
        fieldName: 'name',
        order: 0
      });

      await column.update({ isEditable: true });
      expect(column.isEditable).toBe(true);
    });

    it('should set custom width', async () => {
      const column = await FilterColumnAP.create({
        filterId: testFilter.id,
        fieldName: 'name',
        order: 0,
        width: 200
      });

      expect(column.width).toBe(200);
    });
  });

  describe('associations', () => {
    it('should belong to filter', async () => {
      const column = await FilterColumnAP.create({
        filterId: testFilter.id,
        fieldName: 'name',
        order: 0
      });

      const loaded = await FilterColumnAP.findOne({
        where: { id: column.id },
        include: ['filter']
      });

      expect(loaded!.filter).toBeDefined();
      expect(loaded!.filter.id).toBe(testFilter.id);
    });
  });
});
```

### 1.8.3 CustomFieldHandler —Ç–µ—Å—Ç—ã

**–§–∞–π–ª:** `tests/lib/filter-conditions/CustomFieldHandler.test.ts`

```typescript
import { CustomFieldHandler } from '../../../src/lib/filter-conditions/CustomFieldHandler';

describe('CustomFieldHandler', () => {
  beforeEach(() => {
    // –û—á–∏—Å—Ç–∏—Ç—å registry –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º —Ç–µ—Å—Ç–æ–º
    CustomFieldHandler.clear();
  });

  describe('register', () => {
    it('should register handler', () => {
      CustomFieldHandler.register('Test.field', {
        name: 'Test Handler',
        buildCondition: () => ({ rawSQL: 'test' })
      });

      const handler = CustomFieldHandler.get('Test.field');
      expect(handler).toBeDefined();
      expect(handler!.name).toBe('Test Handler');
    });

    it('should throw error when registering duplicate', () => {
      CustomFieldHandler.register('Test.field', {
        name: 'Test Handler',
        buildCondition: () => ({ rawSQL: 'test' })
      });

      expect(() => {
        CustomFieldHandler.register('Test.field', {
          name: 'Duplicate',
          buildCondition: () => ({ rawSQL: 'test' })
        });
      }).toThrow(/already registered/i);
    });

    it('should allow overwrite with force flag', () => {
      CustomFieldHandler.register('Test.field', {
        name: 'Original',
        buildCondition: () => ({ rawSQL: 'original' })
      });

      CustomFieldHandler.register('Test.field', {
        name: 'Overwrite',
        buildCondition: () => ({ rawSQL: 'overwrite' })
      }, { force: true });

      const handler = CustomFieldHandler.get('Test.field');
      expect(handler!.name).toBe('Overwrite');
    });
  });

  describe('get', () => {
    it('should return handler if exists', () => {
      CustomFieldHandler.register('Test.field', {
        name: 'Test',
        buildCondition: () => ({ rawSQL: 'test' })
      });

      const handler = CustomFieldHandler.get('Test.field');
      expect(handler).toBeDefined();
    });

    it('should return undefined if not exists', () => {
      const handler = CustomFieldHandler.get('NonExistent.field');
      expect(handler).toBeUndefined();
    });
  });

  describe('getForModel', () => {
    it('should return all handlers for model', () => {
      CustomFieldHandler.register('Order.phone', {
        name: 'Phone',
        buildCondition: () => ({ rawSQL: 'test' })
      });

      CustomFieldHandler.register('Order.email', {
        name: 'Email',
        buildCondition: () => ({ rawSQL: 'test' })
      });

      CustomFieldHandler.register('User.name', {
        name: 'Name',
        buildCondition: () => ({ rawSQL: 'test' })
      });

      const orderHandlers = CustomFieldHandler.getForModel('Order');
      expect(orderHandlers.size).toBe(2);
      expect(orderHandlers.has('Order.phone')).toBe(true);
      expect(orderHandlers.has('Order.email')).toBe(true);
      expect(orderHandlers.has('User.name')).toBe(false);
    });
  });

  describe('buildCondition - dialects', () => {
    it('should build PostgreSQL condition', () => {
      CustomFieldHandler.register('Order.phone', {
        name: 'Phone',
        buildCondition: (operator, value, dialect) => {
          if (dialect === 'postgres') {
            return {
              rawSQL: `(phone->>'number') LIKE $1`,
              params: [`%${value}%`]
            };
          }
          return { rawSQL: 'fallback' };
        }
      });

      const handler = CustomFieldHandler.get('Order.phone')!;
      const result = handler.buildCondition('like', '900', 'postgres');

      expect(result.rawSQL).toContain('->>'');
      expect(result.params).toEqual(['%900%']);
    });

    it('should build MySQL condition', () => {
      CustomFieldHandler.register('Order.phone', {
        name: 'Phone',
        buildCondition: (operator, value, dialect) => {
          if (dialect === 'mysql') {
            return {
              rawSQL: `JSON_UNQUOTE(JSON_EXTRACT(phone, '$.number')) LIKE ?`,
              params: [`%${value}%`]
            };
          }
          return { rawSQL: 'fallback' };
        }
      });

      const handler = CustomFieldHandler.get('Order.phone')!;
      const result = handler.buildCondition('like', '900', 'mysql');

      expect(result.rawSQL).toContain('JSON_EXTRACT');
      expect(result.params).toEqual(['%900%']);
    });

    it('should build Waterline in-memory condition', () => {
      CustomFieldHandler.register('Order.phone', {
        name: 'Phone',
        buildCondition: (operator, value, dialect) => {
          if (dialect === 'waterline') {
            return {
              inMemory: (record) => {
                const phone = record.phone?.number || '';
                return phone.includes(value);
              }
            };
          }
          return { rawSQL: 'fallback' };
        }
      });

      const handler = CustomFieldHandler.get('Order.phone')!;
      const result = handler.buildCondition('like', '900', 'waterline');

      expect(result.inMemory).toBeDefined();
      expect(result.inMemory!({ phone: { number: '9001234567' } })).toBe(true);
      expect(result.inMemory!({ phone: { number: '1234567890' } })).toBe(false);
    });
  });

  describe('validate', () => {
    it('should validate value if validator provided', () => {
      CustomFieldHandler.register('Order.phone', {
        name: 'Phone',
        buildCondition: () => ({ rawSQL: 'test' }),
        validate: (value) => {
          if (typeof value !== 'string' || value.length < 3) {
            return { valid: false, error: 'Phone too short' };
          }
          return { valid: true };
        }
      });

      const handler = CustomFieldHandler.get('Order.phone')!;
      
      expect(handler.validate!('12')).toEqual({
        valid: false,
        error: 'Phone too short'
      });

      expect(handler.validate!('123')).toEqual({
        valid: true
      });
    });

    it('should not require validator', () => {
      CustomFieldHandler.register('Order.simple', {
        name: 'Simple',
        buildCondition: () => ({ rawSQL: 'test' })
        // no validate
      });

      const handler = CustomFieldHandler.get('Order.simple')!;
      expect(handler.validate).toBeUndefined();
    });
  });
});
```

---

## 1.9 Integration —Ç–µ—Å—Ç—ã

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** P1
**–í—Ä–µ–º—è:** 0.5 –¥–Ω—è

### 1.9.1 –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏

**–§–∞–π–ª:** `tests/integration/models/transactions.test.ts`

```typescript
import { FilterAP, FilterColumnAP, UserAP } from '../../../src/models';
import { sequelize } from '../../../src/lib/db';

describe('Model Transactions', () => {
  let testUser: UserAP;

  beforeAll(async () => {
    testUser = await UserAP.create({
      login: 'txuser',
      email: 'tx@test.com',
      passwordHashed: 'hash'
    });
  });

  afterAll(async () => {
    await FilterAP.destroy({ where: {} });
    await UserAP.destroy({ where: {} });
  });

  it('should rollback on error', async () => {
    const transaction = await sequelize.transaction();

    try {
      const filter = await FilterAP.create({
        name: 'TX Test',
        modelName: 'UserAP',
        slug: 'tx-test',
        conditions: [],
        ownerId: testUser.id
      }, { transaction });

      await FilterColumnAP.create({
        filterId: filter.id,
        fieldName: 'name',
        order: 0
      }, { transaction });

      // –ò–º–∏—Ç–∞—Ü–∏—è –æ—à–∏–±–∫–∏
      throw new Error('Simulated error');
    } catch (error) {
      await transaction.rollback();
    }

    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –Ω–∏—á–µ–≥–æ –Ω–µ —Å–æ—Ö—Ä–∞–Ω–∏–ª–æ—Å—å
    const filter = await FilterAP.findOne({ where: { slug: 'tx-test' } });
    expect(filter).toBeNull();
  });

  it('should commit on success', async () => {
    const transaction = await sequelize.transaction();

    try {
      const filter = await FilterAP.create({
        name: 'TX Success',
        modelName: 'UserAP',
        slug: 'tx-success',
        conditions: [],
        ownerId: testUser.id
      }, { transaction });

      await FilterColumnAP.create({
        filterId: filter.id,
        fieldName: 'name',
        order: 0
      }, { transaction });

      await transaction.commit();
    } catch (error) {
      await transaction.rollback();
      throw error;
    }

    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —Å–æ—Ö—Ä–∞–Ω–∏–ª–æ—Å—å
    const filter = await FilterAP.findOne({ 
      where: { slug: 'tx-success' },
      include: ['columns']
    });
    
    expect(filter).toBeDefined();
    expect(filter!.columns.length).toBe(1);
  });
});
```

### 1.9.2 Cascade Delete

**–§–∞–π–ª:** `tests/integration/models/cascade.test.ts`

```typescript
describe('Cascade Delete', () => {
  it('should cascade delete columns when filter deleted', async () => {
    const user = await UserAP.create({
      login: 'cascade',
      email: 'cascade@test.com',
      passwordHashed: 'hash'
    });

    const filter = await FilterAP.create({
      name: 'Cascade',
      modelName: 'UserAP',
      slug: 'cascade',
      conditions: [],
      ownerId: user.id
    });

    const columns = await FilterColumnAP.bulkCreate([
      { filterId: filter.id, fieldName: 'id', order: 0 },
      { filterId: filter.id, fieldName: 'name', order: 1 }
    ]);

    // –£–¥–∞–ª–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä
    await filter.destroy();

    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –∫–æ–ª–æ–Ω–∫–∏ —Ç–æ–∂–µ —É–¥–∞–ª–∏–ª–∏—Å—å
    for (const column of columns) {
      const found = await FilterColumnAP.findOne({ where: { id: column.id } });
      expect(found).toBeNull();
    }
  });
});
```

### 1.9.3 –ú–∏–≥—Ä–∞—Ü–∏–∏

**–§–∞–π–ª:** `tests/integration/migrations/filter-ap.test.ts`

```typescript
import { QueryInterface } from 'sequelize';
import { up, down } from '../../../src/migrations/YYYYMMDDHHMMSS-create-filter-ap';
import { sequelize } from '../../../src/lib/db';

describe('FilterAP Migration', () => {
  const queryInterface: QueryInterface = sequelize.getQueryInterface();

  it('should run up migration', async () => {
    await up(queryInterface);

    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —Ç–∞–±–ª–∏—Ü—ã —Å–æ–∑–¥–∞–Ω—ã
    const tables = await queryInterface.showAllTables();
    expect(tables).toContain('FilterAP');
    expect(tables).toContain('FilterColumnAP');

    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∏–Ω–¥–µ–∫—Å—ã
    const indexes = await queryInterface.showIndex('FilterAP');
    expect(indexes.some(idx => idx.fields.includes('modelName'))).toBe(true);
    expect(indexes.some(idx => idx.fields.includes('slug'))).toBe(true);
  });

  it('should run down migration', async () => {
    await up(queryInterface);
    await down(queryInterface);

    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —Ç–∞–±–ª–∏—Ü—ã —É–¥–∞–ª–µ–Ω—ã
    const tables = await queryInterface.showAllTables();
    expect(tables).not.toContain('FilterAP');
    expect(tables).not.toContain('FilterColumnAP');
  });

  it('should be idempotent (safe to run multiple times)', async () => {
    // –ü–µ—Ä–≤—ã–π —Ä–∞–∑
    await up(queryInterface);
    
    // –í—Ç–æ—Ä–æ–π —Ä–∞–∑ - –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—à–∏–±–∫–∏
    await expect(up(queryInterface)).resolves.not.toThrow();
  });
});
```

---

## Test Coverage Report

–ü–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞ –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤ Phase 1:

```bash
npm test -- tests/models tests/integration/models --coverage
```

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**

```
File                                | % Stmts | % Branch | % Funcs | % Lines
------------------------------------|---------|----------|---------|--------
src/models/FilterAP.ts              |   95.2  |   92.3   |  100.0  |   95.1
src/models/FilterColumnAP.ts        |   93.8  |   90.0   |  100.0  |   93.5
src/lib/filter-conditions/
  CustomFieldHandler.ts             |   94.5  |   88.9   |  100.0  |   94.3
------------------------------------|---------|----------|---------|--------
All files                           |   94.5  |   90.4   |  100.0  |   94.3
```

---

## Checklist –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ—Ö–æ–¥–æ–º –∫ –§–∞–∑–µ 2

### –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –¥–ª—è –º–æ–¥–µ–ª–∏

**–§–∞–π–ª:** `fixture/models/Order.ts`

```typescript
import { CustomFieldHandler } from '../../src/lib/filter-conditions/CustomFieldHandler';

export const OrderAPSchema = {
  attributes: {
    id: { type: 'number', primaryKey: true },
    phone: { type: 'json' }, // { countryCode: '+7', number: '9001234567' }
    status: { type: 'string' }
  }
};

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –¥–ª—è –ø–æ–ª—è phone
CustomFieldHandler.register('Order.phone', {
  name: 'Phone Search',
  description: 'Search by phone number in JSON field',
  
  // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ SQL —É—Å–ª–æ–≤–∏–µ
  buildCondition: (operator, value, dialect) => {
    // value = '9001234567' –∏–ª–∏ '+79001234567'
    const cleanNumber = value.replace(/[^0-9]/g, '');
    
    if (dialect === 'postgres') {
      // PostgreSQL - –∏—Å–ø–æ–ª—å–∑—É–µ–º jsonb –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã
      return {
        rawSQL: `(phone->>'number') LIKE $1`,
        params: [`%${cleanNumber}%`]
      };
    } else if (dialect === 'mysql') {
      // MySQL - –∏—Å–ø–æ–ª—å–∑—É–µ–º JSON_EXTRACT
      return {
        rawSQL: `JSON_UNQUOTE(JSON_EXTRACT(phone, '$.number')) LIKE ?`,
        params: [`%${cleanNumber}%`]
      };
    } else {
      // Waterline fallback - in-memory —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è
      return {
        inMemory: (record) => {
          const phone = record.phone?.number || '';
          return phone.includes(cleanNumber);
        }
      };
    }
  },
  
  // –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–Ω–∞—á–µ–Ω–∏—è
  validate: (value) => {
    if (typeof value !== 'string' || value.length < 3) {
      return { valid: false, error: 'Phone number too short' };
    }
    return { valid: true };
  }
});

// –ë–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–π –ø—Ä–∏–º–µ—Ä - –ø–æ–∏—Å–∫ –ø–æ –¥–∏–∞–ø–∞–∑–æ–Ω—É –¥–∞—Ç –≤ JSON
CustomFieldHandler.register('Order.metadata.deliveryDate', {
  name: 'Delivery Date Range',
  description: 'Search by delivery date stored in metadata JSON',
  
  buildCondition: (operator, value, dialect) => {
    // value = { from: '2024-01-01', to: '2024-12-31' }
    
    if (dialect === 'postgres') {
      return {
        rawSQL: `(metadata->>'deliveryDate')::date BETWEEN $1 AND $2`,
        params: [value.from, value.to]
      };
    } else if (dialect === 'mysql') {
      return {
        rawSQL: `STR_TO_DATE(JSON_UNQUOTE(JSON_EXTRACT(metadata, '$.deliveryDate')), '%Y-%m-%d') BETWEEN ? AND ?`,
        params: [value.from, value.to]
      };
    }
  }
});
```

---

### –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã CustomFieldHandler —Å rawSQL

> **üìå –í–ê–ñ–ù–û:** –í—Å–µ –ø—Ä–∏–º–µ—Ä—ã –Ω–∏–∂–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è SQL injection.
> –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ `params` –º–∞—Å—Å–∏–≤, –ù–ò–ö–û–ì–î–ê –Ω–µ –¥–µ–ª–∞–π—Ç–µ –∫–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏—é —Å—Ç—Ä–æ–∫ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º –≤–≤–æ–¥–æ–º!

#### –ü—Ä–∏–º–µ—Ä 1: –í—ã—á–∏—Å–ª—è–µ–º–æ–µ –ø–æ–ª–µ (—Å–∫–∏–¥–∫–∞ –≤ —Ä—É–±–ª—è—Ö)

```typescript
CustomFieldHandler.register('Order.discountAmount', {
  name: 'Discount Amount',
  description: 'Filter by calculated discount amount in currency',
  
  buildCondition: (operator, value, dialect) => {
    // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ: total_price * (discount_percent / 100)
    // –û–ø–µ—Ä–∞—Ç–æ—Ä –º–æ–∂–µ—Ç –±—ã—Ç—å: '>', '>=', '<', '<=', '='
    
    if (dialect === 'postgres') {
      return {
        rawSQL: `(total_price * (discount_percent / 100.0)) ${operator} $1`,
        params: [value]
      };
    } else if (dialect === 'mysql') {
      return {
        rawSQL: `(total_price * (discount_percent / 100.0)) ${operator} ?`,
        params: [value]
      };
    } else {
      // Waterline fallback
      return {
        inMemory: (record) => {
          const amount = record.total_price * (record.discount_percent / 100);
          switch (operator) {
            case '>': return amount > value;
            case '>=': return amount >= value;
            case '<': return amount < value;
            case '<=': return amount <= value;
            case '=': return amount === value;
            default: return false;
          }
        }
      };
    }
  },
  
  validate: (value) => {
    if (typeof value !== 'number' || value < 0) {
      return { valid: false, error: 'Discount amount must be a positive number' };
    }
    return { valid: true };
  }
});
```

#### –ü—Ä–∏–º–µ—Ä 2: –ü–æ–ª–Ω–æ—Ç–µ–∫—Å—Ç–æ–≤—ã–π –ø–æ–∏—Å–∫ (PostgreSQL + MySQL)

```typescript
CustomFieldHandler.register('Product.fulltext', {
  name: 'Full-Text Search',
  description: 'Search across title and description with relevance ranking',
  
  buildCondition: (operator, value, dialect) => {
    if (dialect === 'postgres') {
      return {
        rawSQL: `to_tsvector('english', title || ' ' || description) @@ plainto_tsquery('english', $1)`,
        params: [value]
      };
    } else if (dialect === 'mysql') {
      return {
        rawSQL: `MATCH(title, description) AGAINST(? IN BOOLEAN MODE)`,
        params: [value]
      };
    } else {
      // Fallback –¥–ª—è Waterline
      return {
        inMemory: (record) => {
          const searchText = `${record.title || ''} ${record.description || ''}`.toLowerCase();
          return searchText.includes(value.toLowerCase());
        }
      };
    }
  },
  
  validate: (value) => {
    if (typeof value !== 'string' || value.length < 2) {
      return { valid: false, error: 'Search query must be at least 2 characters' };
    }
    // –ó–∞—â–∏—Ç–∞ –æ—Ç SQL injection - –∑–∞–ø—Ä–µ—Ç–∏—Ç—å –æ–ø–∞—Å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
    if (/[;'"\-\-\/\*]/.test(value)) {
      return { valid: false, error: 'Invalid characters in search query' };
    }
    return { valid: true };
  }
});
```

#### –ü—Ä–∏–º–µ—Ä 3: –ì–µ–æ–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫ (—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏)

```typescript
CustomFieldHandler.register('Store.distance', {
  name: 'Distance From Point',
  description: 'Find stores within radius from coordinates',
  
  buildCondition: (operator, value, dialect) => {
    // value = { lat: 55.7558, lng: 37.6173, radius: 10 } (—Ä–∞–¥–∏—É—Å –≤ –∫–º)
    const { lat, lng, radius } = value;
    
    if (dialect === 'postgres') {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º PostGIS —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
      return {
        rawSQL: `ST_DWithin(
          location::geography,
          ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography,
          $3 * 1000
        )`,
        params: [lng, lat, radius] // —Ä–∞–¥–∏—É—Å –≤ –∫–º -> –º–µ—Ç—Ä—ã
      };
    } else if (dialect === 'mysql') {
      // Haversine formula –¥–ª—è MySQL
      return {
        rawSQL: `(
          6371 * acos(
            cos(radians(?)) * cos(radians(latitude)) * 
            cos(radians(longitude) - radians(?)) + 
            sin(radians(?)) * sin(radians(latitude))
          )
        ) <= ?`,
        params: [lat, lng, lat, radius]
      };
    } else {
      // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π Haversine –¥–ª—è Waterline
      return {
        inMemory: (record) => {
          const R = 6371; // —Ä–∞–¥–∏—É—Å –ó–µ–º–ª–∏ –≤ –∫–º
          const dLat = (record.latitude - lat) * Math.PI / 180;
          const dLng = (record.longitude - lng) * Math.PI / 180;
          const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat * Math.PI / 180) * Math.cos(record.latitude * Math.PI / 180) *
                    Math.sin(dLng/2) * Math.sin(dLng/2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
          const distance = R * c;
          return distance <= radius;
        }
      };
    }
  },
  
  validate: (value) => {
    if (!value || typeof value !== 'object') {
      return { valid: false, error: 'Value must be an object with lat, lng, radius' };
    }
    if (typeof value.lat !== 'number' || typeof value.lng !== 'number' || typeof value.radius !== 'number') {
      return { valid: false, error: 'lat, lng, and radius must be numbers' };
    }
    if (value.lat < -90 || value.lat > 90) {
      return { valid: false, error: 'Latitude must be between -90 and 90' };
    }
    if (value.lng < -180 || value.lng > 180) {
      return { valid: false, error: 'Longitude must be between -180 and 180' };
    }
    if (value.radius <= 0 || value.radius > 10000) {
      return { valid: false, error: 'Radius must be between 0 and 10000 km' };
    }
    return { valid: true };
  }
});
```

#### –ü—Ä–∏–º–µ—Ä 4: –ê–≥—Ä–µ–≥–∞—Ü–∏—è –ø–æ —Å–≤—è–∑–∞–Ω–Ω—ã–º –¥–∞–Ω–Ω—ã–º (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫–∞–∑–æ–≤)

```typescript
CustomFieldHandler.register('User.ordersCount', {
  name: 'Orders Count',
  description: 'Filter users by number of orders',
  
  buildCondition: (operator, value, dialect) => {
    // –û–ø–µ—Ä–∞—Ç–æ—Ä –º–æ–∂–µ—Ç –±—ã—Ç—å: '>', '>=', '<', '<=', '='
    
    if (dialect === 'postgres') {
      return {
        rawSQL: `id IN (
          SELECT user_id 
          FROM orders 
          GROUP BY user_id 
          HAVING COUNT(*) ${operator} $1
        )`,
        params: [value]
      };
    } else if (dialect === 'mysql') {
      return {
        rawSQL: `id IN (
          SELECT user_id 
          FROM orders 
          GROUP BY user_id 
          HAVING COUNT(*) ${operator} ?
        )`,
        params: [value]
      };
    }
  },
  
  validate: (value) => {
    if (typeof value !== 'number' || value < 0 || !Number.isInteger(value)) {
      return { valid: false, error: 'Orders count must be a non-negative integer' };
    }
    return { valid: true };
  }
});
```

#### –ü—Ä–∏–º–µ—Ä 5: –ú–∞—Å—Å–∏–≤ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã (PostgreSQL JSONB)

```typescript
CustomFieldHandler.register('Post.tagsContainAll', {
  name: 'Tags Contain All',
  description: 'Filter posts that contain all specified tags',
  
  buildCondition: (operator, value, dialect) => {
    // value = ['javascript', 'react', 'typescript']
    
    if (dialect === 'postgres') {
      return {
        rawSQL: `tags @> $1::jsonb`,
        params: [JSON.stringify(value)]
      };
    } else if (dialect === 'mysql') {
      // –î–ª—è MySQL –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º AND —É—Å–ª–æ–≤–∏—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–µ–≥–∞
      const conditions = value.map((_, i) => `JSON_CONTAINS(tags, JSON_QUOTE(?), '$')`).join(' AND ');
      return {
        rawSQL: conditions,
        params: value
      };
    } else {
      return {
        inMemory: (record) => {
          if (!Array.isArray(record.tags)) return false;
          return value.every((tag: string) => record.tags.includes(tag));
        }
      };
    }
  },
  
  validate: (value) => {
    if (!Array.isArray(value) || value.length === 0) {
      return { valid: false, error: 'Value must be a non-empty array of tags' };
    }
    if (!value.every(v => typeof v === 'string')) {
      return { valid: false, error: 'All tags must be strings' };
    }
    return { valid: true };
  }
});
```

#### –ü—Ä–∏–º–µ—Ä 6: Regex –ø–æ–∏—Å–∫ —Å —Ñ–ª–∞–≥–∞–º–∏

```typescript
CustomFieldHandler.register('Product.regexMatch', {
  name: 'Regex Match',
  description: 'Match field against regular expression pattern',
  
  buildCondition: (operator, value, dialect) => {
    // value = { pattern: '^PRO-\\d{4}$', flags: 'i' }
    const { pattern, flags } = value;
    
    if (dialect === 'postgres') {
      const pgOperator = flags?.includes('i') ? '~*' : '~';
      return {
        rawSQL: `sku ${pgOperator} $1`,
        params: [pattern]
      };
    } else if (dialect === 'mysql') {
      return {
        rawSQL: `sku REGEXP ?`,
        params: [pattern]
      };
    } else {
      return {
        inMemory: (record) => {
          try {
            const regex = new RegExp(pattern, flags || '');
            return regex.test(record.sku || '');
          } catch (e) {
            console.error('Invalid regex:', e);
            return false;
          }
        }
      };
    }
  },
  
  validate: (value) => {
    if (!value || typeof value !== 'object' || !value.pattern) {
      return { valid: false, error: 'Value must have pattern property' };
    }
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ regex –≤–∞–ª–∏–¥–Ω—ã–π
    try {
      new RegExp(value.pattern, value.flags || '');
    } catch (e) {
      return { valid: false, error: `Invalid regex pattern: ${e.message}` };
    }
    return { valid: true };
  }
});
```

#### –ü—Ä–∏–º–µ—Ä 7: –î–∞—Ç–∞ —Å —É—á–µ—Ç–æ–º –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∑–æ–Ω—ã

```typescript
CustomFieldHandler.register('Event.dateInTimezone', {
  name: 'Date in Timezone',
  description: 'Filter by date converted to specific timezone',
  
  buildCondition: (operator, value, dialect) => {
    // value = { date: '2024-01-15', timezone: 'America/New_York' }
    const { date, timezone } = value;
    
    if (dialect === 'postgres') {
      return {
        rawSQL: `(event_date AT TIME ZONE $1)::date ${operator} $2::date`,
        params: [timezone, date]
      };
    } else if (dialect === 'mysql') {
      // MySQL —Ç—Ä–µ–±—É–µ—Ç CONVERT_TZ
      return {
        rawSQL: `DATE(CONVERT_TZ(event_date, 'UTC', ?)) ${operator} DATE(?)`,
        params: [timezone, date]
      };
    }
  },
  
  validate: (value) => {
    if (!value || !value.date || !value.timezone) {
      return { valid: false, error: 'Value must have date and timezone properties' };
    }
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã
    if (!/^\d{4}-\d{2}-\d{2}$/.test(value.date)) {
      return { valid: false, error: 'Date must be in YYYY-MM-DD format' };
    }
    return { valid: true };
  }
});
```

---

### üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ rawSQL

**–ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û:**

1. **–í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã:**
   ```typescript
   // ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û
   rawSQL: `field = $1`,
   params: [userInput]
   
   // ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û - SQL Injection!
   rawSQL: `field = '${userInput}'`
   ```

2. **–û–±—è–∑–∞—Ç–µ–ª—å–Ω–∞ –≤–∞–ª–∏–¥–∞—Ü–∏—è –≤ –º–µ—Ç–æ–¥–µ `validate()`:**
   ```typescript
   validate: (value) => {
     // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–∞
     if (typeof value !== 'string') return { valid: false, error: 'Must be string' };
     
     // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª–∏–Ω—ã
     if (value.length > 100) return { valid: false, error: 'Too long' };
     
     // –ó–∞–ø—Ä–µ—Ç –æ–ø–∞—Å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
     if (/[;'"\-\-\/\*]/.test(value)) return { valid: false, error: 'Invalid chars' };
     
     return { valid: true };
   }
   ```

3. **–û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–π—Ç–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã:**
   ```typescript
   buildCondition: (operator, value, dialect) => {
     // Whitelist —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
     const allowedOps = ['=', '>', '<', '>=', '<=', '!='];
     if (!allowedOps.includes(operator)) {
       throw new Error(`Operator ${operator} not allowed`);
     }
     // ...
   }
   ```

4. **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ prepared statements:**
   - PostgreSQL: `$1, $2, $3`
   - MySQL/MariaDB: `?, ?, ?`
   - –ù–∏–∫–æ–≥–¥–∞ –Ω–µ —Å–∫–ª–µ–∏–≤–∞–π—Ç–µ —Å—Ç—Ä–æ–∫–∏!

```

---
```

---

### –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≤ adminizerConfig

**–§–∞–π–ª:** `fixture/adminizerConfig.ts`

```typescript
export default {
  models: {
    Order: {
      model: 'OrderAP',
      title: 'Orders',
      
      fields: {
        phone: {
          type: 'json',
          title: 'Phone',
          
          // –£–∫–∞–∑—ã–≤–∞–µ–º —á—Ç–æ –ø–æ–ª–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∫–∞—Å—Ç–æ–º–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
          customHandler: 'Order.phone',
          
          // –î–æ—Å—Ç—É–ø–Ω—ã–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—è
          filterOperators: [
            {
              id: 'contains',
              label: 'Contains number',
              requiresValue: true,
              valueType: 'text',
              placeholder: 'Enter phone number'
            }
          ],
          
          // –ö–∞—Å—Ç–æ–º–Ω—ã–π UI –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
          display: (value) => {
            if (!value) return '-';
            return `${value.countryCode} ${value.number}`;
          }
        },
        
        metadata: {
          type: 'json',
          title: 'Metadata',
          
          // –í–ª–æ–∂–µ–Ω–Ω—ã–µ –ø–æ–ª—è —Å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞–º–∏
          fields: {
            deliveryDate: {
              title: 'Delivery Date',
              customHandler: 'Order.metadata.deliveryDate',
              filterOperators: [
                {
                  id: 'between',
                  label: 'Date range',
                  requiresValue: true,
                  valueType: 'dateRange'
                }
              ]
            }
          }
        },
        
        // –ü—Ä–∏–º–µ—Ä —Å –ø–æ–ª–Ω—ã–º raw SQL
        complexCalculation: {
          type: 'virtual',
          title: 'Complex Calculation',
          
          filterOperators: [
            {
              id: 'raw',
              label: 'Custom SQL',
              requiresValue: true,
              
              // –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä SQL –¥–ª—è —ç—Ç–æ–≥–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞
              buildSQL: (value, dialect) => {
                if (dialect === 'postgres') {
                  return {
                    sql: `(total_price * discount_percent / 100) > $1`,
                    params: [value]
                  };
                }
                return {
                  sql: `(total_price * discount_percent / 100) > ?`,
                  params: [value]
                };
              }
            }
          ]
        }
      }
    }
  }
};
```

---

### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ —Ñ–∏–ª—å—Ç—Ä–∞—Ö

**–ü—Ä–∏–º–µ—Ä 1: –ü–æ–∏—Å–∫ –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É**

```typescript
const filter = {
  modelName: 'Order',
  conditions: [
    {
      id: '1',
      field: 'phone',
      operator: 'custom',
      customHandler: 'Order.phone',
      value: '9001234567'
    }
  ]
};

// –†–µ–∑—É–ª—å—Ç–∞—Ç –≤ SQL (PostgreSQL):
// WHERE (phone->>'number') LIKE '%9001234567%'
```

**–ü—Ä–∏–º–µ—Ä 2: Raw SQL –¥–ª—è —Å–ª–æ–∂–Ω–æ–≥–æ —É—Å–ª–æ–≤–∏—è**

```typescript
const filter = {
  modelName: 'Order',
  conditions: [
    {
      id: '1',
      field: 'total',
      operator: 'custom',
      rawSQL: `(total_price * (1 - discount_percent / 100)) > $1`,
      rawSQLParams: [1000]
    }
  ]
};
```

**–ü—Ä–∏–º–µ—Ä 3: –ö–æ–º–±–∏–Ω–∞—Ü–∏—è –æ–±—ã—á–Ω—ã—Ö –∏ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π**

```typescript
const filter = {
  modelName: 'Order',
  conditions: [
    {
      id: 'group1',
      logic: 'AND',
      children: [
        {
          id: '1',
          field: 'status',
          operator: 'eq',
          value: 'pending'
        },
        {
          id: '2',
          field: 'phone',
          operator: 'custom',
          customHandler: 'Order.phone',
          value: '900'
        },
        {
          id: '3',
          field: 'created',
          operator: 'gt',
          value: '2024-01-01'
        }
      ]
    }
  ]
};
```

---

## Checklist –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ—Ö–æ–¥–æ–º –∫ –§–∞–∑–µ 2

- [x] –ú–æ–¥–µ–ª–∏ —Å–æ–∑–¥–∞–Ω—ã –∏ —Ä–∞–±–æ—Ç–∞—é—Ç
- [x] –ú–∏–≥—Ä–∞—Ü–∏–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ
- [x] –°–≤—è–∑–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
- [x] JSON –ø–æ–ª—è —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è/–∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ
- [x] –£–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å slug —Ä–∞–±–æ—Ç–∞–µ—Ç
- [x] Unit —Ç–µ—Å—Ç—ã –¥–ª—è FilterAP/FilterColumnAP –Ω–∞–ø–∏—Å–∞–Ω—ã (24 —Ç–µ—Å—Ç–∞)
- [ ] Integration —Ç–µ—Å—Ç—ã –Ω–∞–ø–∏—Å–∞–Ω—ã (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
- [ ] –ö–æ–¥ –æ—Ç—Ä–µ–≤—å—é–µ–Ω

---

## –ó–∞–º–µ—Ç–∫–∏

_–î–æ–±–∞–≤–ª—è–π—Ç–µ –∑–∞–º–µ—Ç–∫–∏ –ø–æ —Ö–æ–¥—É —Ä–∞–±–æ—Ç—ã_
