> ⚠️ **AI-DRAFT**
>
> This document was generated by a neural network and may contain inaccuracies or mistakes.

# Next.js + Adminizer (кейс `nyachik-connect`)

## Область применения

Этот документ восстановлен по реальным коммитам проекта:

- `36ea9f5` - `feat: add sequelize data layer and adminizer`
- `15d2c6f` - `test: ensure adminizer route prefix`

Цель: показать, что именно было добавлено для рабочей интеграции Adminizer в Next.js с Sequelize + SQLite.

## Что было сделано

1. Добавлены зависимости для Adminizer + Sequelize + SQLite.
2. Добавлен `next.config.mjs` с server-runtime настройками для ORM/Adminizer.
3. Реализована singleton-инициализация Sequelize и регистрация моделей.
4. Добавлен singleton bootstrap для Adminizer (`src/server/adminizer/index.ts`).
5. Добавлен конфиг Adminizer (`src/server/adminizer/config.ts`) с описанием моделей для UI.
6. Добавлен catch-all API маршрут (`src/pages/api/adminizer/[[...adminizer]].ts`) с проксированием в middleware Adminizer.
7. Добавлен тест, фиксирующий `routePrefix = "/adminizer"`.

## Изменения по файлам (коммит `36ea9f5`)

- `.gitignore`
- `data/.gitkeep`
- `next.config.mjs`
- `package.json`
- `src/lib/models/service-category.ts`
- `src/lib/models/service-offer.ts`
- `src/lib/models/service-booking.ts`
- `src/lib/models/index.ts`
- `src/lib/sequelize.ts`
- `src/server/adminizer/config.ts`
- `src/server/adminizer/index.ts`
- `src/pages/api/adminizer/[[...adminizer]].ts`

## Шаг 1. Установка зависимостей

Используется тот же набор зависимостей, что и в интеграционном коммите:

```bash
npm install adminizer sequelize sqlite3
npm install -D @types/sqlite3
```

Позже в ветке добавили тесты префикса маршрута через Vitest (`15d2c6f`):

```bash
npm install -D vitest
```

## Шаг 2. Настройка Next.js runtime

В интеграционном коммите использовался такой `next.config.mjs`:

```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  experimental: {
    typedRoutes: true,
    serverComponentsExternalPackages: ["sequelize", "sqlite3", "adminizer"],
  },
  outputFileTracingIncludes: {
    "/*": [
      "./node_modules/sqlite3/build/Release/**/*",
      "./node_modules/sqlite3/lib/binding/**/*",
      "./src/lib/**/*",
      "./src/server/adminizer/**/*",
    ],
  },
  images: {
    remotePatterns: [
      {
        protocol: "https",
        hostname: "images.unsplash.com",
      },
      {
        protocol: "https",
        hostname: "firebasestorage.googleapis.com",
      },
      {
        protocol: "https",
        hostname: "storage.googleapis.com",
      },
    ],
  },
};

export default nextConfig;
```


Важные детали этой конфигурации:

- `serverComponentsExternalPackages` оставляет нативные/ORM пакеты внешними для server runtime.
- `outputFileTracingIncludes` гарантирует, что sqlite binary и серверный код adminizer попадут в билд.

## Шаг 3. Подготовка слоя БД (Sequelize)

### 3.1 `.gitignore` и каталог данных

```gitignore
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Playwright MCP cache
.playwright-mcp

# Documentation
docs
.next
# Database
data/*.sqlite
```


`data/.gitkeep` добавлен, чтобы каталог базы данных оставался в git.

### 3.2 Реестр Sequelize-моделей

```ts
import { Sequelize } from "sequelize";
import { ServiceCategory, initServiceCategory } from "./service-category";
import { ServiceOffer, initServiceOffer } from "./service-offer";
import { ServiceBooking, initServiceBooking } from "./service-booking";

export function initModels(sequelize: Sequelize) {
  initServiceCategory(sequelize);
  initServiceOffer(sequelize);
  initServiceBooking(sequelize);

  ServiceCategory.hasMany(ServiceOffer, {
    as: "offers",
    foreignKey: "categoryId",
  });

  ServiceOffer.belongsTo(ServiceCategory, {
    as: "category",
    foreignKey: "categoryId",
  });

  ServiceOffer.hasMany(ServiceBooking, {
    as: "bookings",
    foreignKey: "offerId",
  });

  ServiceBooking.belongsTo(ServiceOffer, {
    as: "offer",
    foreignKey: "offerId",
  });

  return {
    ServiceCategory,
    ServiceOffer,
    ServiceBooking,
  } as const;
}

export type Models = ReturnType<typeof initModels>;

export { ServiceCategory, ServiceOffer, ServiceBooking };
```


### 3.3 Модель `ServiceCategory`

```ts
import {
  CreationOptional,
  DataTypes,
  InferAttributes,
  InferCreationAttributes,
  Model,
  Sequelize,
} from "sequelize";

export class ServiceCategory extends Model<
  InferAttributes<ServiceCategory>,
  InferCreationAttributes<ServiceCategory>
> {
  declare id: CreationOptional<number>;
  declare name: string;
  declare description: string | null;
  declare slug: CreationOptional<string>;
  declare shortDescription: string;
  declare createdAt: CreationOptional<Date>;
  declare updatedAt: CreationOptional<Date>;

  get summary() {
    const description = this.getDataValue("description");
    return description ? `${this.name}: ${description}` : this.name;
  }
}

export function initServiceCategory(sequelize: Sequelize) {
  ServiceCategory.init(
    {
      id: {
        type: DataTypes.INTEGER.UNSIGNED,
        autoIncrement: true,
        primaryKey: true,
      },
      name: {
        type: DataTypes.STRING(120),
        allowNull: false,
        unique: true,
      },
      description: {
        type: DataTypes.TEXT,
        allowNull: true,
      },
      slug: {
        type: DataTypes.STRING(150),
        allowNull: false,
        unique: true,
      },
      shortDescription: {
        type: DataTypes.VIRTUAL,
        get(this: ServiceCategory) {
          const description = this.getDataValue("description");
          if (!description) return "Описание отсутствует";
          return description.length > 120
            ? `${description.slice(0, 117).trim()}...`
            : description;
        },
      },
      createdAt: DataTypes.DATE,
      updatedAt: DataTypes.DATE,
    },
    {
      tableName: "service_categories",
      modelName: "ServiceCategory",
      sequelize,
      hooks: {
        beforeValidate(category) {
          if (!category.slug && category.name) {
            category.slug = category.name
              .trim()
              .toLowerCase()
              .replace(/[^a-z0-9\u0400-\u04FF]+/g, "-")
              .replace(/^-+|-+$/g, "");
          }
        },
      },
      defaultScope: {
        order: [["name", "ASC"]],
      },
    }
  );

  return ServiceCategory;
}
```


### 3.4 Модель `ServiceOffer`

```ts
import {
  CreationOptional,
  DataTypes,
  InferAttributes,
  InferCreationAttributes,
  Model,
  NonAttribute,
  Sequelize,
} from "sequelize";
import { ServiceCategory } from "./service-category";

export type OfferStatus = "draft" | "published" | "archived";

export class ServiceOffer extends Model<
  InferAttributes<ServiceOffer, { omit: "category" }>,
  InferCreationAttributes<ServiceOffer, { omit: "category" }>
> {
  declare id: CreationOptional<number>;
  declare title: string;
  declare summary: string;
  declare description: string | null;
  declare price: number;
  declare currency: string;
  declare durationMinutes: number | null;
  declare providerName: string;
  declare providerEmail: string | null;
  declare providerPhone: string | null;
  declare meetingPoint: string | null;
  declare status: OfferStatus;
  declare isFeatured: CreationOptional<boolean>;
  declare isActive: CreationOptional<boolean>;
  declare categoryId: number;
  declare category?: NonAttribute<ServiceCategory>;
  declare createdAt: CreationOptional<Date>;
  declare updatedAt: CreationOptional<Date>;
  declare displayPrice: string;
  declare providerContact: string;
}

export function initServiceOffer(sequelize: Sequelize) {
  ServiceOffer.init(
    {
      id: {
        type: DataTypes.INTEGER.UNSIGNED,
        autoIncrement: true,
        primaryKey: true,
      },
      title: {
        type: DataTypes.STRING(180),
        allowNull: false,
      },
      summary: {
        type: DataTypes.STRING(280),
        allowNull: false,
      },
      description: {
        type: DataTypes.TEXT,
        allowNull: true,
      },
      price: {
        type: DataTypes.INTEGER.UNSIGNED,
        allowNull: false,
      },
      currency: {
        type: DataTypes.STRING(3),
        allowNull: false,
        defaultValue: "VND",
      },
      durationMinutes: {
        type: DataTypes.INTEGER,
        allowNull: true,
      },
      providerName: {
        type: DataTypes.STRING(120),
        allowNull: false,
      },
      providerEmail: {
        type: DataTypes.STRING(160),
        allowNull: true,
        validate: {
          isEmail: true,
        },
      },
      providerPhone: {
        type: DataTypes.STRING(40),
        allowNull: true,
      },
      meetingPoint: {
        type: DataTypes.STRING(160),
        allowNull: true,
      },
      status: {
        type: DataTypes.ENUM("draft", "published", "archived"),
        allowNull: false,
        defaultValue: "published",
      },
      isFeatured: {
        type: DataTypes.BOOLEAN,
        allowNull: false,
        defaultValue: false,
      },
      isActive: {
        type: DataTypes.BOOLEAN,
        allowNull: false,
        defaultValue: true,
      },
      categoryId: {
        type: DataTypes.INTEGER.UNSIGNED,
        allowNull: false,
        references: {
          model: ServiceCategory,
          key: "id",
        },
        onDelete: "CASCADE",
      },
      displayPrice: {
        type: DataTypes.VIRTUAL,
        get(this: ServiceOffer) {
          const price = this.getDataValue("price");
          const currency = this.getDataValue("currency");
          return new Intl.NumberFormat("ru-RU", {
            style: "currency",
            currency,
            maximumFractionDigits: 0,
          }).format(price ?? 0);
        },
      },
      providerContact: {
        type: DataTypes.VIRTUAL,
        get(this: ServiceOffer) {
          const email = this.getDataValue("providerEmail");
          const phone = this.getDataValue("providerPhone");
          if (email && phone) return `${email} / ${phone}`;
          return email ?? phone ?? "Контакты не указаны";
        },
      },
      createdAt: DataTypes.DATE,
      updatedAt: DataTypes.DATE,
    },
    {
      tableName: "service_offers",
      modelName: "ServiceOffer",
      sequelize,
      defaultScope: {
        order: [["createdAt", "DESC"]],
      },
    }
  );

  return ServiceOffer;
}
```


### 3.5 Модель `ServiceBooking`

```ts
import {
  CreationOptional,
  DataTypes,
  InferAttributes,
  InferCreationAttributes,
  Model,
  NonAttribute,
  Sequelize,
} from "sequelize";
import { ServiceOffer } from "./service-offer";

export type BookingStatus = "pending" | "confirmed" | "completed" | "cancelled";

export class ServiceBooking extends Model<
  InferAttributes<ServiceBooking, { omit: "offer" }>,
  InferCreationAttributes<ServiceBooking, { omit: "offer" }>
> {
  declare id: CreationOptional<number>;
  declare customerName: string;
  declare customerEmail: string;
  declare customerPhone: string | null;
  declare attendees: number;
  declare scheduledFor: Date;
  declare status: BookingStatus;
  declare basePrice: number;
  declare serviceFee: number;
  declare currency: string;
  declare specialRequests: string | null;
  declare offerId: number;
  declare offer?: NonAttribute<ServiceOffer>;
  declare createdAt: CreationOptional<Date>;
  declare updatedAt: CreationOptional<Date>;
  declare totalPrice: number;
  declare statusLabel: string;
  declare formattedSchedule: string;
}

const STATUS_LABELS: Record<BookingStatus, string> = {
  pending: "Ожидает подтверждения",
  confirmed: "Подтверждено",
  completed: "Завершено",
  cancelled: "Отменено",
};

export function initServiceBooking(sequelize: Sequelize) {
  ServiceBooking.init(
    {
      id: {
        type: DataTypes.INTEGER.UNSIGNED,
        autoIncrement: true,
        primaryKey: true,
      },
      customerName: {
        type: DataTypes.STRING(160),
        allowNull: false,
      },
      customerEmail: {
        type: DataTypes.STRING(160),
        allowNull: false,
        validate: {
          isEmail: true,
        },
      },
      customerPhone: {
        type: DataTypes.STRING(40),
        allowNull: true,
      },
      attendees: {
        type: DataTypes.INTEGER.UNSIGNED,
        allowNull: false,
        defaultValue: 1,
      },
      scheduledFor: {
        type: DataTypes.DATE,
        allowNull: false,
      },
      status: {
        type: DataTypes.ENUM("pending", "confirmed", "completed", "cancelled"),
        allowNull: false,
        defaultValue: "pending",
      },
      basePrice: {
        type: DataTypes.INTEGER.UNSIGNED,
        allowNull: false,
        defaultValue: 0,
      },
      serviceFee: {
        type: DataTypes.INTEGER.UNSIGNED,
        allowNull: false,
        defaultValue: 0,
      },
      currency: {
        type: DataTypes.STRING(3),
        allowNull: false,
        defaultValue: "VND",
      },
      specialRequests: {
        type: DataTypes.TEXT,
        allowNull: true,
      },
      offerId: {
        type: DataTypes.INTEGER.UNSIGNED,
        allowNull: false,
        references: {
          model: ServiceOffer,
          key: "id",
        },
        onDelete: "CASCADE",
      },
      totalPrice: {
        type: DataTypes.VIRTUAL,
        get(this: ServiceBooking) {
          const base = this.getDataValue("basePrice") ?? 0;
          const fee = this.getDataValue("serviceFee") ?? 0;
          return base + fee;
        },
      },
      statusLabel: {
        type: DataTypes.VIRTUAL,
        get(this: ServiceBooking) {
          const status = this.getDataValue("status") as BookingStatus;
          return STATUS_LABELS[status] ?? status;
        },
      },
      formattedSchedule: {
        type: DataTypes.VIRTUAL,
        get(this: ServiceBooking) {
          const date = this.getDataValue("scheduledFor");
          if (!date) return "Дата не выбрана";
          return new Intl.DateTimeFormat("ru-RU", {
            dateStyle: "long",
            timeStyle: "short",
          }).format(date);
        },
      },
      createdAt: DataTypes.DATE,
      updatedAt: DataTypes.DATE,
    },
    {
      tableName: "service_bookings",
      modelName: "ServiceBooking",
      sequelize,
      defaultScope: {
        order: [["scheduledFor", "ASC"]],
      },
    }
  );

  return ServiceBooking;
}
```


### 3.6 Singleton/bootstrap Sequelize

```ts
import { Sequelize } from "sequelize";
import { initModels, Models } from "./models";

const globalForSequelize = globalThis as unknown as {
  __sequelize?: Sequelize;
  __sequelizeModels?: Models;
  __sequelizeSyncPromise?: Promise<void>;
};

const databaseUrl = process.env.DATABASE_URL ?? "sqlite:./data/community.sqlite";

const sequelizeInstance =
  globalForSequelize.__sequelize ??
  new Sequelize(databaseUrl, {
    logging: process.env.NODE_ENV === "development" ? console.log : false,
  });

const modelsInstance = globalForSequelize.__sequelizeModels ?? initModels(sequelizeInstance);

if (!globalForSequelize.__sequelize) {
  globalForSequelize.__sequelize = sequelizeInstance;
  globalForSequelize.__sequelizeModels = modelsInstance;
}

export const sequelize = sequelizeInstance;
export const models = modelsInstance;

export async function ensureDatabase() {
  if (process.env.NODE_ENV !== "production" && process.env.SKIP_DB_SYNC !== "true") {
    if (!globalForSequelize.__sequelizeSyncPromise) {
      globalForSequelize.__sequelizeSyncPromise = sequelize.sync();
    }
    await globalForSequelize.__sequelizeSyncPromise;
  }
}
```


## Шаг 4. Инициализация Adminizer

### 4.1 Конфиг Adminizer (route, auth, models, fields)

```ts
import type { AdminpanelConfig } from "adminizer";

export const adminizerConfig: AdminpanelConfig = {
  routePrefix: "/adminizer",
  system: {
    defaultORM: "sequelize",
  },
  auth: {
    enable: true,
    captcha: false,
    description: "Войдите, чтобы управлять данными сообщества",
  },
  administrator: {
    login: process.env.ADMINIZER_LOGIN ?? "community",
    password: process.env.ADMINIZER_PASSWORD ?? "connect123",
  },
  translation: {
    locales: ["ru", "en"],
    defaultLocale: "ru",
    path: "translations",
  },
  welcome: {
    title: "Панель сообщества Нячанг",
    text: "Управляйте услугами, бронированиями и категориями",
  },
  navbar: {
    additionalLinks: [
      {
        id: "back-to-site",
        title: "На сайт",
        link: "/",
        type: "self",
        icon: "home",
      },
      {
        id: "checkout",
        title: "Форма заявки",
        link: "/checkout",
        type: "self",
        icon: "assignment",
      },
    ],
  },
  models: {
    ServiceCategory: {
      title: "Категории услуг",
      model: "ServiceCategory",
      icon: "category",
      list: {
        fields: {
          id: true,
          name: true,
          slug: {
            title: "Слаг",
            visible: true,
          },
          shortDescription: {
            title: "Краткое описание",
            visible: true,
          },
        },
        defaultSort: {
          field: "name",
          order: "ASC",
        },
      },
      fields: {
        id: {
          title: "ID",
          disabled: true,
        },
        name: {
          title: "Название",
          required: true,
        },
        slug: {
          title: "Слаг",
          description: "Генерируется автоматически, но можно задать вручную",
        },
        description: {
          title: "Описание",
          type: "textarea",
        },
        createdAt: {
          title: "Создано",
          type: "datetime",
          disabled: true,
        },
        updatedAt: {
          title: "Обновлено",
          type: "datetime",
          disabled: true,
        },
      },
      create: {
        fields: {
          slug: false,
          createdAt: false,
          updatedAt: false,
        },
      },
      edit: {
        fields: {
          createdAt: false,
          updatedAt: false,
        },
      },
    },
    ServiceOffer: {
      title: "Услуги",
      model: "ServiceOffer",
      icon: "miscellaneous_services",
      list: {
        fields: {
          title: true,
          status: {
            title: "Статус",
            visible: true,
          },
          displayPrice: {
            title: "Стоимость",
            visible: true,
          },
          providerName: {
            title: "Исполнитель",
            visible: true,
          },
          category: {
            title: "Категория",
            visible: true,
            display: (record) => record.category?.name,
          },
        },
        filters: {
          status: {
            title: "Статус",
            type: "select",
            options: ["draft", "published", "archived"],
          },
          isActive: {
            title: "Активна",
            type: "boolean",
          },
        },
        defaultSort: {
          field: "createdAt",
          order: "DESC",
        },
      },
      fields: {
        id: {
          title: "ID",
          disabled: true,
        },
        title: {
          title: "Название",
          required: true,
        },
        summary: {
          title: "Краткое описание",
          type: "textarea",
          required: true,
        },
        description: {
          title: "Полное описание",
          type: "textarea",
        },
        categoryId: {
          title: "Категория",
          type: "relation",
          relation: {
            model: "ServiceCategory",
            displayField: "name",
            searchField: "name",
          },
          required: true,
        },
        price: {
          title: "Цена (VND)",
          type: "number",
          description: "Указывается за одного участника",
        },
        currency: {
          title: "Валюта",
          type: "select",
          isIn: ["VND", "USD"],
          defaultValue: "VND",
        },
        durationMinutes: {
          title: "Длительность (мин)",
          type: "number",
        },
        providerName: {
          title: "Исполнитель",
          required: true,
        },
        providerEmail: {
          title: "Email исполнителя",
          type: "email",
        },
        providerPhone: {
          title: "Телефон исполнителя",
        },
        meetingPoint: {
          title: "Локация встречи",
        },
        status: {
          title: "Статус",
          type: "select",
          isIn: ["draft", "published", "archived"],
          enum: {
            draft: "Черновик",
            published: "Опубликовано",
            archived: "Архив",
          },
          defaultValue: "published",
        },
        isFeatured: {
          title: "В подборке",
          type: "boolean",
          defaultValue: false,
        },
        isActive: {
          title: "Активна",
          type: "boolean",
          defaultValue: true,
        },
        createdAt: {
          title: "Создано",
          type: "datetime",
          disabled: true,
        },
        updatedAt: {
          title: "Обновлено",
          type: "datetime",
          disabled: true,
        },
      },
      create: {
        fields: {
          createdAt: false,
          updatedAt: false,
        },
      },
      edit: {
        fields: {
          createdAt: false,
          updatedAt: false,
        },
      },
    },
    ServiceBooking: {
      title: "Заявки",
      model: "ServiceBooking",
      icon: "event_available",
      list: {
        fields: {
          customerName: {
            title: "Клиент",
            visible: true,
          },
          statusLabel: {
            title: "Статус",
            visible: true,
          },
          scheduledFor: {
            title: "Дата",
            visible: true,
          },
          totalPrice: {
            title: "Сумма",
            visible: true,
          },
        },
        filters: {
          status: {
            title: "Статус",
            type: "select",
            options: ["pending", "confirmed", "completed", "cancelled"],
          },
        },
        defaultSort: {
          field: "scheduledFor",
          order: "DESC",
        },
      },
      fields: {
        id: {
          title: "ID",
          disabled: true,
        },
        customerName: {
          title: "Имя клиента",
          required: true,
        },
        customerEmail: {
          title: "Email",
          type: "email",
          required: true,
        },
        customerPhone: {
          title: "Телефон",
        },
        attendees: {
          title: "Участники",
          type: "number",
        },
        scheduledFor: {
          title: "Назначено на",
          type: "datetime",
        },
        status: {
          title: "Статус",
          type: "select",
          isIn: ["pending", "confirmed", "completed", "cancelled"],
          enum: {
            pending: "Ожидает",
            confirmed: "Подтверждено",
            completed: "Завершено",
            cancelled: "Отменено",
          },
        },
        specialRequests: {
          title: "Пожелания",
          type: "textarea",
        },
        offerId: {
          title: "Услуга",
          type: "relation",
          relation: {
            model: "ServiceOffer",
            displayField: "title",
            searchField: "title",
          },
        },
        basePrice: {
          title: "Базовая сумма",
          type: "number",
        },
        serviceFee: {
          title: "Комиссия",
          type: "number",
        },
        currency: {
          title: "Валюта",
        },
        createdAt: {
          title: "Создано",
          type: "datetime",
          disabled: true,
        },
        updatedAt: {
          title: "Обновлено",
          type: "datetime",
          disabled: true,
        },
      },
      edit: {
        fields: {
          createdAt: false,
          updatedAt: false,
        },
      },
    },
  },
};
```


### 4.2 Singleton-инициализация Adminizer

```ts
import { Adminizer, SequelizeAdapter } from "adminizer";
import { adminizerConfig } from "./config";
import { sequelize } from "@/lib/sequelize";

const globalForAdminizer = globalThis as unknown as {
  __adminizerPromise?: Promise<Adminizer>;
};

export async function getAdminizer(): Promise<Adminizer> {
  if (!globalForAdminizer.__adminizerPromise) {
    globalForAdminizer.__adminizerPromise = (async () => {
      const adapter = new SequelizeAdapter(sequelize);
      const adminizer = new Adminizer([adapter]);
      await adminizer.init(adminizerConfig);
      return adminizer;
    })();
  }
  return globalForAdminizer.__adminizerPromise;
}

export async function getAdminizerMiddleware() {
  const adminizer = await getAdminizer();
  return adminizer.getMiddleware();
}
```


Почему здесь нужен singleton:

- В Next.js dev-режиме и serverless-подобном исполнении модули могут инициализироваться повторно.
- Кэш через `globalThis` защищает от повторных `adminizer.init(...)` и дублирующего bootstrap адаптера.

## Шаг 5. Проксирование запросов Next.js в Adminizer middleware

Создаётся catch-all API маршрут:

```ts
import type { NextApiRequest, NextApiResponse } from "next";
import { getAdminizerMiddleware } from "@/server/adminizer";

export const config = {
  api: {
    bodyParser: false,
    externalResolver: true,
  },
};

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const middleware = await getAdminizerMiddleware();
    await new Promise<void>((resolve, reject) => {
      const next = (err?: unknown) => {
        if (err) reject(err);
        else resolve();
      };
      middleware(req, res, next);
    });
  } catch (error) {
    console.error("Adminizer error:", error);
    res.status(500).json({ message: "Админ-панель недоступна" });
  }
}
```


Этот маршрут делает две критичные вещи:

- Отключает встроенный body parser (`bodyParser: false`), чтобы Adminizer middleware сам обработал тело запроса.
- Оборачивает callback middleware в Promise, чтобы Next API handler корректно дожидался завершения.

## Шаг 6. Тест на префикс маршрута

Добавлено в коммите `15d2c6f`:

```ts
import { describe, it, expect } from "vitest";
import { adminizerConfig } from "./config";

describe("adminizer configuration", () => {
  it("указывает корректный префикс маршрута админ-панели", () => {
    expect(adminizerConfig.routePrefix).toBe("/adminizer");
  });
});
```


В `package.json` этого же коммита добавлен test-скрипт:

```json
{
  "scripts": {
    "test": "vitest run"
  }
}
```

## Шаг 7. Переменные окружения в интеграции

```bash
# SQLite db path
DATABASE_URL=sqlite:./data/community.sqlite

# Adminizer credentials
ADMINIZER_LOGIN=community
ADMINIZER_PASSWORD=connect123

# Optional: skip sync in dev if needed
SKIP_DB_SYNC=true
```

## Шаг 8. Проверка работы

```bash
npm install
npm run dev
```

После запуска проверить:

1. Открыть настроенный префикс панели (`/adminizer` в этом кейсе).
2. Убедиться, что появилась форма входа.
3. Войти под `ADMINIZER_LOGIN` / `ADMINIZER_PASSWORD`.
4. Проверить, что видны модели `ServiceCategory`, `ServiceOffer`, `ServiceBooking`.
5. Создать/обновить записи и проверить, что в терминале нет ошибок сервера.

## Нюанс именно этого коммита

Префикс маршрута явно зафиксирован как `/adminizer` (и покрыт тестом). Транспортный маршрут реализован через `src/pages/api/adminizer/[[...adminizer]].ts`. При переносе в другой проект обязательно синхронизируйте внешний URL панели и внутреннюю маршрутизацию Next.js.

## Быстрый план внедрения (минимальный порядок)

1. Установить `adminizer`, `sequelize`, `sqlite3`.
2. Добавить `next.config.mjs` с runtime/tracing настройками.
3. Добавить Sequelize-модели и singleton `src/lib/sequelize.ts`.
4. Добавить `src/server/adminizer/config.ts` и `src/server/adminizer/index.ts`.
5. Добавить catch-all API маршрут `src/pages/api/adminizer/[[...adminizer]].ts`.
6. Добавить тест на `routePrefix`.
7. Запустить приложение и проверить вход + CRUD в Adminizer.
